# ―概要―  

**sakura.io Evaluation Board(以下、検証用ボード)用のサンプルプログラム集です。**  
・通信モジュールと組み合わせて使うことで、sakura.ioの検証を行うことができます。  
・通信モジュールが無くても、一部プログラムを除き、検証用ボードだけの動作を楽しむことができます。  
・ソースコードも同梱していますので、改造や開発の参考にすることができます。  


# ―ライセンスについて―  
このソフトウェアはMITライセンスのもとで公開されます。詳細は「LICENSE」を参照願います。  
（This software is released under the MIT License, see LICENSE.）

# ―お借りしたライブラリについて―
「EVB_SampleWebApp」内の以下のファイル類について  

・「data」  
・「libs」  
・「motion」  
・「src」  
・「main.js」  
・「MMD.js」  
・「index.html」  
 
**これらファイル類は私が作成したものではなく、以下で配布されているライブラリを使用・改造したものになります。** 

edvakf様「MMD.js」: <https://github.com/edvakf/MMD.js>


# ―クイックリファレンス―

「まずはプログラムの動作を見たい」という方は、ファイル一覧のうち  
・SakuraIOEvaluationBoardSampleApp.bin  
を検証用ボードに書き込んでください。  
このファイルは、検証用ボードにすぐ書き込める実行ファイルです。  


# ―プログラム操作方法―
サンプルプログラムは全部で6種類あります。  
検証用ボードを起動するとプログラム選択画面が出てきますので以下の操作でプログラムを選択します。

1.「STM32Reset」ボタンを押し、基板をリセットすると、アプリケーション選択画面になる。  
2.SW1でカウントアップ、SW2でカウントダウンするので、お好みのアプリケーションを選択する。  
3.SW4押下で決定。選択されたアプリケーションが実行される。  
4.別のアプリケーションを動作させたい場合は1.に戻る。    

※SW6はLCDのバックライト点灯スイッチです。(6側でOFF、7側(LCD側)で点灯)

App No.の対応は以下の通りです。  
1.スイッチ＆LED確認用テストプログラム  
2.「逃げるLED」  
3.「24時間時計」  
4.「温湿度・気圧測定計」(通信モジュール使用推奨)  
5.「『MMD on WebGL』ライブラリを使用した、3Dモデル操作」(通信モジュール必須)  
6.「GPS送受信機」(通信モジュール使用推奨)  
7.「sakura.ioリバーシ」(通信モジュール必須)  

**プログラムの取り扱い説明は「CSakuraIOEvaluationBoard.h」内にコメントで記述していますのでそちらを参照願います。**

「通信モジュール使用推奨」は、検証用ボード単体での動作が可能ですが、同梱したWebアプリケーションでデータを表示するためには通信モジュールが必要です。  
「通信モジュール必須」は、通信モジュールがないと動作確認を行うことができません。


# ―プログラム使用上の注意―
**以下の4つのプログラムは通信モジュールの使用を考慮に入れていますので、sakura.ioポイントを消費します。**

4.「温湿度・気圧測定計」(通信モジュール使用推奨)  
5.「『MMD on WebGL』ライブラリを使用した、3Dモデル操作」(通信モジュール必須)  
6.「GPS送受信機」(通信モジュール使用推奨)  
7.「sakura.ioリバーシ」(通信モジュール必須)  

**検証用ボード上のスイッチ操作で通信モジュールの通信をON-OFF設定できる機能を持たせてはいますが、操作方法を確認せずこれらプログラムを使用するとsakura.ioポイントを無用に消費する恐れがあります。  
ご使用になる前に必ず「CSakuraIOEvaluationBoard.h」内にコメントした、各プログラムの取り扱い説明を熟読お願いいたします。**


# ―サンプルWebアプリケーションについて―
「EVB_SampleWebApp」フォルダ内に3つのHTMLファイルがあり、Web側のアプリケーションとして動作します。検証用ボードのアプリケーションとの対応は以下のようになっています。

「bme280\_test.html」    ― 4.「温湿度・気圧測定計」  
「index.html」          ― 5.「『MMD on WebGL』ライブラリを使用した、3Dモデル操作」  
「gps\_xa1110_test.html」― 6.「GPS送受信機」  
「sakuraio\_reversi.html」―7.「sakura.ioリバーシ」  

これらのうち「index.html」「gps\_xa1110_test.html」「sakuraio\_reversi.html」については事前準備が必要ですので下記説明ご参照願います。
  
**これらWebアプリケーションを使用する場合、検証用ボードに通信モジュールを搭載する必要があります。**


# ―サンプルWebアプリケーション使い方(共通)―

・それぞれのWebアプリケーションには「URL」入力欄がありますので、通信モジュールのWebSocketのURLを入力して下さい。  
・「module」入力欄がある場合は通信モジュールのIDを入力して下さい。

以上を入力した後、「接続」ボタンを押下するとWebアプリケーション側の準備は完了です。  
通信モジュールを搭載した検証用ボードからの送信データに応じて、Webアプリケーションが動作します。  
但し、「gps\_xa1110_test.html」「index.html」については以下の準備が必要になります。  

# ―「gps\_xa1110_test.html」使用前の準備について―
「gps\_xa1110_test.html」は検証用ボードから送信されたGPSセンサーの値を元にGoogleMapにピン表示するという内容ですが、動作には「APIキー」というものが必要になります。  

APIキーを取得したらそれをソースコードに記述する必要があります(APIキーの取得方法については他の解説に譲ります)

「gps\_xa1110_test.html」ソースコード内の下部に以下のコードがあります。  

```
<script src="https://maps.googleapis.com/maps/api/js?key=/*ここにGoogleMapをJavaScriptで使うためのAPIキーを入力*/&callback=initMap">initMap()</script>
```  

このコードのうち、「/\*ここにGoogleMapをJavaScriptで使うためのAPIキーを入力\*/」を削除し、取得したAPIキーを記述し、上書き保存してください。
これでWebアプリケーション側の準備が完了になります。


# ―「index.html」使用前の準備について―  
ブラウザに表示させたMMDモデルを検証用ボードに連動させて動かす、というアプリケーションですがMMDモデルデータは同梱していないので  
**edvakf様「MMD.js」**: <https://github.com/edvakf/MMD.js>  
にて公開されているファイル群のうち「model」フォルダ内のデータが必要です。

・上記リンクからデータを一式ダウンロードする。(ZIP形式でローカルに保存)  
・解凍し、「model」フォルダを「EVB_SampleWebApp」フォルダ内にコピー

これで準備が完了です。  


# ―「sakuraio\_reversi.html」使用前の準備について―
「sakuraio\_reversi.html」は検証用ボード対Web画面(sakuraio\_reversi.html)とで勝負するリバーシとなっております。  
「sakuraio\_reversi.html」のファイル内にWebSocketのURLと通信モジュールのIDを設定する必要があり、ソースコード内の上部に以下のコードがあります。  

```
//WebSocket関係ここから
    // 接続先URI(ここにWebSocketのURLを記述する)
    var uri = "";
    
    //通信モジュールID(ここに通信モジュールのIDを記述する)
    var module_id = "";
```  

このコードのuriとmodule\_idの二つの変数にWebSocketのURLと通信モジュールのIDを記述し、上書き保存して下さい。  
これでWebアプリケーション側の準備が完了になります。


# ―サンプルWebアプリケーション使い方(bme280\_test.html)―
WebSocket通信で"検証用ボード→Webアプリケーション"の片方向でデータを送信します。

・「URL」入力欄がありますので、通信モジュールのWebSocketのURLを入力し、接続ボタンを押します。  
・検証用ボードからの温湿度データに基づいて、空気線図上にデータをプロットします。  

  
# ―サンプルWebアプリケーション使い方(index.html)―
WebSocket通信で"検証用ボード→Webアプリケーション"の片方向でデータを送信します。  

・「URL」入力欄がありますので、通信モジュールのWebSocketのURLを入力し、接続ボタンを押します。    
・検証用ボード傾けたり、回したりすると、Webアプリケーション上のMMDモデルがその方向に動きます(X軸回転、Z軸回転)   
・Webアプリケーション上のボタン説明は以下の通りです。  
「X軸回転+」「X軸回転-」「Z軸回転+」「Z軸回転-」:MMDモデルをそれぞれの軸周りで回転させます。  
「初期位置」:MMDモデルを初期位置にします。  

注意点として、検証用ボードの角度ではなく「角度の変化量」に応じて動くので  
**検証用ボードの傾き＝MMDモデルの傾き**  
とはならないです。  

**ヒント1**：検証用ボードは極力ゆっくり一定に動かしてみてください。あまりにも変な角度になった場合は「初期位置」ボタンを押下してください。  
  
**ヒント2**：「main.js」内のソースコードを変更すると表示するMMDモデルを変更できます。また、動作は保証できませんが独自に用意したMMDモデル(.pmd)に変更することも可能です。詳細は「main.js」ファイル内のコメントを参照願います。  

※サーバにアップせず、ローカルで使う場合（Google Chromeを使用する場合）
ブラウザの起動オプションを設定しないとローカルでは動かない場合があります。
起動オプションの設定は以下の通りです。

・「Google Chrome」を右クリックし、「ショートカット」タブを選択  
・「リンク先(T)」の末尾に「 --allow-file-access-from-files」を追加後、「適用(A)」押下し「OK」ボタン押下  

これで、ローカル環境でも動きます。


# ―サンプルWebアプリケーション使い方(gps\_xa1110_test.html)―
WebSocket通信で"検証用ボード⇔Webアプリケーション"の双方向でデータを送受信します。  

・「URL」「module」入力欄がありますので、通信モジュールのWebSocketのURL及びIDを入力し、接続ボタンを押します。  
・通信モジュールから送信された座標データをGoogleマップ上にピン表示します。  
・「現在位置」ボタン押下で、検証用ボードに座標データを送信させることができます。  

・Webアプリケーション上のボタン説明は以下の通りです。  
「現在位置」：検証用ボードに、現在の座標データを送信させます。  
　　　　　　　(Webアプリケーションから検証用ボードへの送信で1ポイント、検証用ボードから
                         Webアプリケーションへの送信で1ポイントの計2ポイント消費します)  
「東京」「新橋」「品川」「札幌テレビ塔」：それぞれの位置をGoogleマップ上でピン表示します。  
「移動軌跡」：「有効」にすると過去のピン表示がマップ上に残ったままになります。「無効」にすると、常に最新のピン表示のみがマップ上残ります。  


# ―サンプルWebアプリケーション使い方(sakuraio\_reversi.html)―
WebSocket通信で"検証用ボード⇔Webアプリケーション"の双方向でデータを送受信します。  
Web側のゲーム画面の説明は以下の画像を参照願います。  
<https://github.com/IsebaLaboMaster/SakuraIOEvaluationBoardSampleApp/issues/2>  

・上記使用前準備を済ませてから画面を開くと、自動的にWebSocket通信を確立します。  
・WebSocket通信が確立すると、「WebSocket 接続状態 : Open」となります。  
(上記使用前準備を済ませていなくても「WebSocket 接続状態 : Open」が出ます。この場合通信は出来ません)  
・「わたし」の手番は検証用ボードから、「あなた」の手番はWebから手を打つことができます。  
・「あなた」の手番(Web側)の時、石を置ける場所をクリックすると手を打つことができます。  
・「わたし」の手番(検証用ボード側)の時、画面をクリックしても手を打つことはできません。  
・プレイヤーの黒番・白番は盤の下部に表示され、現在の手番はプレイヤー名が四角い枠で表示されます。  
・現在の取得石枚数は盤の右側に表示されます。  
・ゲーム途中でF5キーを押下して画面を更新しても、最初は初期配置になりますが、すぐに検証用ボードと通信を行い、現在の盤状態になります。  

※白・黒番設定、ゲームのリセット、盤状態の管理等は全て検証用ボード側で管理しています。    
また、ナダ電子株式会社製「AS-289R2」プリンタシールドをお持ちであれば棋譜を印刷できます。
(詳細は「CSakuraIOEvaluationBoard.h」内の説明を熟読願います)  

# ―プログラムソースコードについて―
mbed上でプログラムを使用して改造等する場合、以下のソースコードを使用します。  
プロジェクトを作成し、以下のソースコードをアップロードしてください。  

・CSwLEDTest.cpp  
・CEscapeLED.cpp  
・CTimerSample.cpp  
・CBME280Sample.cpp  
・CMPU9250Sample.cpp  
・CGNSSXA1110Sample.cpp  
・CSakuraIOEvaluationBoard.h  
・SakuraIOEvaluationBoard.cpp  
・CSakuraIOReversi.cpp  
・main.cpp  
  

その他に必要となるライブラリがあります。  
以下のライブラリが必要になりますので、mbed上でインポートしてください。  
・AQM0802A(<https://os.mbed.com/users/tetsuya256/code/AQM0802A/>)  
・BME280(<https://os.mbed.com/users/MACRUM/code/BME280/>)  
・gps(<https://os.mbed.com/teams/SAKURA-Internet/code/gps/>)  
・MPU9250\_SPI(<https://os.mbed.com/users/kylongmu/code/MPU9250_SPI/>)  
・AS289R2(<https://os.mbed.com/users/MACRUM/code/AS289R2/>)  
・SakuraIO (<https://os.mbed.com/teams/SAKURA-Internet/code/SakuraIO/>)  
  
以上、ソースコードとライブラリを追加した後にコンパイルすると検証用ボードに書き込むための実行ファイルが生成されます。
 

# ―プログラム改造のヒント―
サンプルプログラムは「1classで1プログラム」という形で作成しております。  
classを追加する場合は  
・classの宣言は「CSakuraIOEvaluationBoard.h」に  
・classのソースファイルは別ファイルに  
という風に作成すると整理しやすくなります。  


# ―作者について―
作者：伊勢羽  
HP:Iseba's Labo(<http://iseba-labo.com/>)
